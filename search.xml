<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/09/07/%E9%9B%86%E5%90%88/"/>
      <url>/2024/09/07/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a><center>集合</center></h1><h2 id="集合的框架体系"><a href="#集合的框架体系" class="headerlink" title="集合的框架体系"></a>集合的框架体系</h2><h3 id="集合主要分为两组（单列集合、多列集合）"><a href="#集合主要分为两组（单列集合、多列集合）" class="headerlink" title="集合主要分为两组（单列集合、多列集合）"></a>集合主要分为两组（单列集合、多列集合）</h3><p>1.Collection接口有两个重要的子类接口，Set和List，它们的实现子类都是单列集合</p><p>2.Map接口的实现的子类都是双列集合，即key-value</p><p><a href="images/java/collection/image1.png"></a></p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="Collection接口实现类的特点"><a href="#Collection接口实现类的特点" class="headerlink" title="Collection接口实现类的特点"></a>Collection接口实现类的特点</h3><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>public interface Collection<E> extends Iterable<E></E></E></p><p>1.collection实现的子类可以存放多个元素，每个元素可以是Object</p><p>2.有些collection的实现类，可以存放重复元素，有些不可以</p><p>3.有些collection的实现类，有些是有序的（List），有些是无序的（Set)</p><p>4.Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现</p><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><h6 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h6><p><strong>1.使用Iterator（迭代器）</strong></p><p>基本介绍：</p><p>1.Iterator对象称为迭代器，主要用于遍历Collection集合中的元素</p><p>2.所有实现了Collection接口的集合都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即返回一个迭代器</p><p>3.Iterator仅用于遍历集合，Iterator本身不存放对象</p><p>Iterator接口的方法：hasNext() \next()</p><p>注意：在调用it.next()方法之前必须调用it.hasNext()进行检测，若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。</p><p>执行原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator=col.iterator();<span class="comment">//得到一个集合的迭代器</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;<span class="comment">//判断是否还有下一个元素</span></span><br><span class="line">Object obj=iterator.next();<span class="comment">//指针下移，将下移后集合位置上的元素返回</span></span><br><span class="line">System.out.println(<span class="string">&quot;obj=&quot;</span>+obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.如果希望再次遍历，需重置迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator=col.iterator();</span><br></pre></td></tr></table></figure><p><strong>2.for循环增强</strong></p><p>增强for循环，可以代替iterator迭代器，特点：增强for就是简化版的iterator，本质一样，只能用于遍历集合或数组</p><p>基本语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object object :col)&#123;</span><br><span class="line">System.out.println(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><strong>基本介绍</strong></p><p>1.List集合类中的元素有序（即添加和取出的顺序一致），且可重复</p><p>2.List集合中的每个元素都有对应的顺序索引</p><p>3.List容器中的元素都对应一个整数型的序号记载在容器中的位置，可根据序号存取容器中的元素</p><p><strong>常用方法</strong></p><p>插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line">lsit.add(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.remove(<span class="number">100</span>);<span class="comment">//默认按索引删除</span></span><br><span class="line">list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>));<span class="comment">//按指定元素删除，需要传入对象才行</span></span><br></pre></td></tr></table></figure><p>修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.set(1,&quot;Lim&quot;);</span><br></pre></td></tr></table></figure><p><strong>三种遍历</strong>[ArrayList,LinkedList,Vector]</p><p>1.使用iterator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator iter=col.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">Object obj=iert.next();</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用增强for</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object o :col)&#123;</span><br><span class="line">System.out.println(o)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.使用普通for</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">Object object=list.get(i);</span><br><span class="line">System.out.println(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p><strong>基本介绍</strong></p><p>1.permits all elements,including null, ArrayList可以加入null，并且多个</p><p>2.ArrayList是由数组来实现数组存储的</p><p>3.ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高）</p><p><strong>底层结构和源码分析</strong></p><p>1.ArrayList中维护了一个Object类型的数组elementData.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;<span class="comment">//transient 表示瞬间、短暂的，表示该属性不会被序列化</span></span><br></pre></td></tr></table></figure><p>2.当创建ArrayList对象是，如果使用的是无参构造器，则初始elementData容量为0，第一次添加，则扩容elementData为10，如需再次扩容，则扩容elementData为1.5倍</p><p>3.如果使用的是指定大小的构造器，则elementData容量为指定大小，如果需要扩容，则直接扩容elementData的1.5倍</p><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p><strong>基本介绍</strong></p><p>1.Vector类的定义说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;,RandomAccess,Cloneable,Serializable</span><br></pre></td></tr></table></figure><p>2.Vector底层也是一个对象数组，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br></pre></td></tr></table></figure><p>3.Vector是线程同步的，即线程安全，Vector的操作方法带有syschronized</p><p>4.扩容机制：如果是午餐，默认10，满后就按2倍扩容；如果指定大小，则每次直接按两倍扩</p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><strong>基本介绍</strong></p><p>1.LinkedList底层实现了双向链表和双端队列的特点</p><p>2.可以添加任意元素（元素可重复），包括null</p><p>3.线程不安全，没有实现同步</p><p><strong>底层结构</strong></p><p>1.LinkedList底层维护了一个双向链表</p><p>2.LinkedList中维护了两个属性first和last分别指向首结点和尾结点</p><p>3.每个节点（Node 对象），里面又维护了prev,next,item三个属性，其中通过prev指向前一个，通过next指向后一个节点，最终实现双向链表</p><p>4.所有LinkedList的元素的添加和删除，部署通过数组完成的，相对速度较高</p><p><strong>ArrayList和LinekedList比较</strong></p><table><thead><tr><th></th><th>底层结构</th><th>增删效率</th><th>改查效率</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>较低，数组扩容</td><td>较高</td></tr><tr><td>LinkedList</td><td>双向链表</td><td>较高，通过链表追加</td><td>较低</td></tr></tbody></table><p>如何选择ArrayList和LinkedList</p><p>1.如果改查操作多，用ArrayList</p><p>2.如果增删多，用LinkedList</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1.Set接口的实现类对象（Set接口的对象）,不能存放重复的数据，可以添加null，只能一个）</p><p>2.Set接口存放的数据是无序的</p><p>注意：取得的数据的顺序虽然不是按照添加的顺序，但顺序是固定的</p><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><p>和list接口一样，Set接口也是Collection接口的子接口，因此常用方法和Collection接口一样</p><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><p>1.迭代器</p><p>2.增强for</p><p>3.不能使用索引方式来获取</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p><strong>基本介绍</strong></p><p>1.HashSet实现了Set接口</p><p>2.HashSet实际上是HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span>&#123;</span><br><span class="line">    map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.可以存放null值，但只能有一个null</p><p>4.HashSet不保证元素是有序的，取决余hash后，再确定索引的结果</p><p>5.不能有重复的元素&#x2F;对象</p><p><strong>底层机制</strong></p><p>1.HashSet的底层是HashMap,HashMap底层是（数组+链表+红黑树）</p><p>2.第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子(loadFactor)是0.75&#x3D;12</p><p>3.如果table数组使用到了临界值12，就会扩容到16<em>2&#x3D;32，新的临界值就是32</em>0.75&#x3D;24，以此类推</p><p>4.在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认64)，就会进行树化（红黑树），否则仍然采用数组机制进行扩容</p><hr><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p><strong>基本介绍</strong></p><p>1.LinkedHashSet是HashSet的子类</p><p>2.LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表</p><p>3.LinkedHashSet根据元素hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入的顺序保存的</p><p>4.LinkedHashSet不允许添加重复元素</p><p><strong>底层机制</strong></p><p>1.在LinkedHashSet中维护了一个hash表和双向链表（LinkedHashSet有head和tail）</p><p>2.每一个节点有pre和next属性,这样可以形成双向链表</p><p>3.在添加一个元素时，先求hash值，再求索引，确定该元素在hashtable的位置，然后将添加的元素加入到双向链表（如果已存在，不添加【原则和HashSet一样】）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail.next=<span class="keyword">new</span> <span class="title class_">Element</span>;</span><br><span class="line">newElement.pre=tail;</span><br><span class="line">tail=newElement;</span><br></pre></td></tr></table></figure><p>4.这样的话，我们遍历LinkedHashSet也能确保插入顺序和遍历顺序一致</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h4 id="Map接口实现类的特点"><a href="#Map接口实现类的特点" class="headerlink" title="Map接口实现类的特点"></a>Map接口实现类的特点</h4><p>1.Map与Collection并列存在，用于保存具有映射关系的数据（key-value)</p><p>2.Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中</p><p>3.Map中的Key不允许重复，原因和HashSet一样</p><p>4.Map中的value可以重复</p><p>5.Map中的key可以为null,value也可以为null,注意Key为null,只能有一个，value为null，可以为多个</p><p>6.常用String类作为Map的key</p><p>7.key和value之间存在单向的一对一关系，即通过对应的key总能找到对应的value</p><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/08/26/center%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86center/"/>
      <url>/2024/08/26/center%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86center/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a><center>计算机组成原理</center></h1><h2 id="计算机发展历程"><a href="#计算机发展历程" class="headerlink" title="计算机发展历程"></a>计算机发展历程</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>测试文章</title>
      <link href="/2024/08/01/test/"/>
      <url>/2024/08/01/test/</url>
      
        <content type="html"><![CDATA[<p>此处是文章内容。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="/2024/08/01/java1/"/>
      <url>/2024/08/01/java1/</url>
      
        <content type="html"><![CDATA[<h1 id="补码、反码、原码"><a href="#补码、反码、原码" class="headerlink" title="补码、反码、原码"></a>补码、反码、原码</h1><p>1.二进制的最高位是符号位：0表示正数，1表示负数</p><p>2.正数的原码，反码，补码都一样（三码合一）</p><p>3.负数的反码&#x3D;它的原码符号位不变，其它位取反（0-&gt;1,1-&gt;0）</p><p>4.负数的补码&#x3D;它的反码+1，负数的反码&#x3D;负数的补码-1</p><p>5.0的反码补码都是0</p><p>6.java没有无符号数，换而言之，Java中的数都是有符号的</p><p>7.在计算机运行的时候，都是以补码的方式来运算的</p><p>8.当我们看运算结果的时候，要看它的原码</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>示例文章</title>
      <link href="/2024/07/17/use/"/>
      <url>/2024/07/17/use/</url>
      
        <content type="html"><![CDATA[<p>此处是文章内容。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的配置和使用</title>
      <link href="/2024/07/16/git/"/>
      <url>/2024/07/16/git/</url>
      
        <content type="html"><![CDATA[<h1 id="git的介绍和使用"><a href="#git的介绍和使用" class="headerlink" title="git的介绍和使用"></a><center><strong>git的介绍和使用</strong></center></h1><h2 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h2><p>git提供了一个叫git config 的工具，专门用来配置或读取相应的工作环境变量。这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p><ul><li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 <code>git config</code> 时用 <code>--system</code> 选项，读写的就是这个文件。</li><li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件。</li><li>当前项目的 Git 目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</li></ul><p>在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings$USER。</p><p>此外，Git 还会尝试找寻 &#x2F;etc&#x2F;gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位</p><h3 id="用户信息配置"><a href="#用户信息配置" class="headerlink" title="用户信息配置"></a>用户信息配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email username@outlook.com</span><br></pre></td></tr></table></figure><p>如果使用了–global, 那么更改的配置文件就是位于用户主目录下的那个,以后所有的项目都会默认使用这里配置的用户信息.</p><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>设置git默认使用的文本编辑器,一般是vi或vim, 如果有其它偏好,像emacs, 可重新设置.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor emacs</span><br></pre></td></tr></table></figure><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><p>检查已有的配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">http.postbuffer=2M</span><br><span class="line">user.name=lim</span><br><span class="line">user.email=test@outlook.com</span><br></pre></td></tr></table></figure><p>有时会看到重复的变量名,那就说明它们来自不同的配置文件(比如&#x2F;etc&#x2F;gitconfig和~&#x2F;.gitconfig), 不过最终git实际采用的是最后一个.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.gitconfig</span><br></pre></td></tr></table></figure><p>也可以直接查询某个环境变量的设定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">lim</span><br></pre></td></tr></table></figure><hr><h2 id="git工作流程"><a href="#git工作流程" class="headerlink" title="git工作流程"></a>git工作流程</h2><p>一般工作流程如下</p><ul><li><p>克隆 Git 资源作为工作目录。</p></li><li><p>在克隆的资源上添加或修改文件。</p></li><li><p>如果其他人修改了，你可以更新资源。</p></li><li><p>在提交前查看修改。</p></li><li><p>提交修改。</p></li><li><p>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</p><p>下图展示了git的工作流程</p><p><img src="/images/git/Snipaste_2024-07-16_11-21-48.png"></p><p>+++</p><h2 id="git工作区暂存区和版本库"><a href="#git工作区暂存区和版本库" class="headerlink" title="git工作区暂存区和版本库"></a>git工作区暂存区和版本库</h2><ul><li><p><strong>工作区：</strong>就是你在电脑里能看到的目录。</p></li><li><p><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</p></li><li><p><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</p><p>下图为之间的关系</p><p><img src="/images/git/image2.png"></p><p>+++</p></li></ul><h2 id="git创建仓库"><a href="#git创建仓库" class="headerlink" title="git创建仓库"></a>git创建仓库</h2><p><strong>初始化</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p><strong>提交到暂存区</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p><strong>提交到版本库</strong>(记录版本库中的变化，将暂存区的改动提交到本地的版本库)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;message&quot;</span><br></pre></td></tr></table></figure><p><strong>从现有的git仓库中拷贝项目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure><p><strong>repo</strong>:git仓库</p><p><strong>directory</strong>:本地目录</p><p>+++</p><h2 id="git基本操做"><a href="#git基本操做" class="headerlink" title="git基本操做"></a>git基本操做</h2><p>git的工作就是创建和保存你项目的快照及之后的快照进行对比</p><p>git常用的6个命令:<strong>git clone, git push, git add, git commit, git checkout, git pull</strong>.</p><p><img src="/images/git/image1.png"></p></li></ul><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone</span><br></pre></td></tr></table></figure><h4 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add  添加文件到暂存区</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status  查看仓库当前的状态,显示有变更的文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff比较文件的不同,即暂存区和工作区的差异</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit提交暂存区到本地仓库</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset回退版本</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm将文件从暂存区和工作区删除</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout分支切换</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch更清晰的分支切换</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore恢复或撤销文件的更改</span><br></pre></td></tr></table></figure><h4 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log查看历史提交记录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;file&gt; 以列表的形式查看指定文件的历史修改记录</span><br></pre></td></tr></table></figure><h4 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote远程仓库操作</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch从远程获取代码库</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull下载远程代码并合并</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push上传远程代码并合并</span><br></pre></td></tr></table></figure><p>+++</p><h3 id="git分支管理"><a href="#git分支管理" class="headerlink" title="git分支管理"></a>git分支管理</h3><p>几乎每一种版本控制系统都以某种形式支持分支，一条分支代表一条独立的开发栈。</p><p>使用分支意味着你可以从开发主线上分离开来，然后不影响主线的同时继续工作。</p><p><img src="/images/git/image3.png"></p><p>git分支实际上是指向更改快照的指针</p><p>创建分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch (branchname)</span><br></pre></td></tr></table></figure><p>切换分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout (branchname)</span><br></pre></td></tr></table></figure><p>当你切换分支的时候，Git会用该分支的最后提交的快照替换你的工作目录的内容，所有多个分支不需要多个目录。</p><p>合并分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure><p>查看本地分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>查看远程分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r    -r表示remote</span><br></pre></td></tr></table></figure><p>查看所有分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>+++</p><h2 id="git标签"><a href="#git标签" class="headerlink" title="git标签"></a>git标签</h2><p>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用git tag 给它打上标签。比如我们的project 项目发布一个“1.0”版本。我们可以使用git tag -a v1.0 给最新一个提交打上（head)”v1.0”的标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0</span><br></pre></td></tr></table></figure><p>当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p><p>现在，注意当我们执行 git log –decorate 时，我们可以看到我们的标签了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;</span><br><span class="line">|\  </span><br><span class="line">| * 7774248 (change_site) changed the runoob.php</span><br><span class="line">* | c68142b 修改代码</span><br><span class="line">|/  </span><br><span class="line">* c1501a2 removed test.txt、add runoob.php</span><br><span class="line">* 3e92c19 add test.txt</span><br><span class="line">* 3b58100 第一次版本提交</span><br></pre></td></tr></table></figure><p>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。</p><p>例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.9 85fc7e7</span><br><span class="line">$ git log --oneline --decorate --graph</span><br><span class="line">*   d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;</span><br><span class="line">|\  </span><br><span class="line">| * 7774248 (change_site) changed the runoob.php</span><br><span class="line">* | c68142b 修改代码</span><br><span class="line">|/  </span><br><span class="line">* c1501a2 removed test.txt、add runoob.php</span><br><span class="line">* 3e92c19 add test.txt</span><br><span class="line">* 3b58100 (tag: v0.9) 第一次版本提交</span><br></pre></td></tr></table></figure><p>如果我们要查看所有标签可以使用以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>指定标签信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;tagname&gt; -m &quot;project.com标签&quot;</span><br></pre></td></tr></table></figure><p>PGP签名标签命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -s &lt;tagname&gt; -m &quot;project.com标签&quot;</span><br></pre></td></tr></table></figure><p>删除标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v1.1</span><br></pre></td></tr></table></figure><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。</p><p>所以，标签也是版本库的一个快照。</p><p>Git 的标签虽然是版本库的快照，但其实它就是指向某个 commit 的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Git有commit，为什么还要引入tag？</span><br><span class="line"></span><br><span class="line">&quot;请把上周一的那个版本打包发布，commit号是6a5819e…&quot;</span><br><span class="line"></span><br><span class="line">&quot;一串乱七八糟的数字不好找！&quot;</span><br><span class="line"></span><br><span class="line">如果换一个办法：</span><br><span class="line"></span><br><span class="line">&quot;请把上周一的那个版本打包发布，版本号是v1.2&quot;</span><br><span class="line"></span><br><span class="line">&quot;好的，按照tag v1.2查找commit就行！&quot;</span><br><span class="line"></span><br><span class="line">所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</span><br></pre></td></tr></table></figure><hr><h2 id="git连接远程仓库"><a href="#git连接远程仓库" class="headerlink" title="git连接远程仓库"></a>git连接远程仓库</h2><p><img src="/images/git/image4.png"></p><h4 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h4><p>使用url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]</span><br></pre></td></tr></table></figure><p>使用ssh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:username/repository.git</span><br></pre></td></tr></table></figure><p>检查远程仓库配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>生成ssh key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>后面的 <strong><a href="mailto:&#121;&#x6f;&#117;&#x72;&#95;&#x65;&#109;&#x61;&#105;&#108;&#x40;&#x79;&#x6f;&#x75;&#x72;&#x65;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;">&#121;&#x6f;&#117;&#x72;&#95;&#x65;&#109;&#x61;&#105;&#108;&#x40;&#x79;&#x6f;&#x75;&#x72;&#x65;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;</a></strong> 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。</p><p>成功的话会在 <strong>~&#x2F;</strong> 下生成 <strong>.ssh</strong> 文件夹，进去，打开 <strong>id_rsa.pub</strong>，复制里面的 <strong>key</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;429240967@qq.com&quot;</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/tianqixin/.ssh/id_rsa): </span><br><span class="line">Enter passphrase (empty for no passphrase):    # 直接回车</span><br><span class="line">Enter same passphrase again:                   # 直接回车</span><br><span class="line">Your identification has been saved in /Users/tianqixin/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /Users/tianqixin/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:MDKVidPTDXIQoJwoqUmI4LBAsg5XByBlrOEzkxrwARI 429240967@qq.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 3072]----+</span><br><span class="line">|E*+.+=**oo       |</span><br><span class="line">|%Oo+oo=o. .      |</span><br><span class="line">|%**.o.o.         |</span><br><span class="line">|OO.  o o         |</span><br><span class="line">|+o+     S        |</span><br><span class="line">|.                |</span><br><span class="line">|                 |</span><br><span class="line">|                 |</span><br><span class="line">|                 |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><p>回到 github 上，进入 Account &#x3D;&gt; Settings（账户配置）</p><p><img src="/images/git/image4.png"></p><p>为了验证是否成功，输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">The authenticity of host &#x27;github.com (52.74.223.119)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes                   # 输入 yes</span><br><span class="line">Warning: Permanently added &#x27;github.com,52.74.223.119&#x27; (RSA) to the list of known hosts.</span><br><span class="line">Hi tianqixin! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. # 成功信息</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>…or create a new repository on the command line</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;# java&quot; &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/lim-juyou/java.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p><strong>…or push an existing repository from the command line</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建个人博客并部署到Github</title>
      <link href="/2024/07/16/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0GitHub/"/>
      <url>/2024/07/16/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0GitHub/</url>
      
        <content type="html"><![CDATA[<h5 id><a href="#" class="headerlink" title></a></h5><h5 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h5><p>已安装好git和Node.js</p><h4 id="1-安装Hexo"><a href="#1-安装Hexo" class="headerlink" title="1.安装Hexo"></a>1.安装Hexo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>终端执行<front color="red">hexo -version</front>出现版本号，说明安装成功</p><h4 id="2-本地建站"><a href="#2-本地建站" class="headerlink" title="2.本地建站"></a>2.本地建站</h4><h5 id="2-1初始化"><a href="#2-1初始化" class="headerlink" title="2.1初始化"></a>2.1初始化</h5><p>找到要存放博客的目录，进入终端执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init myblog</span><br><span class="line">cd myblog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>vscode打开myblog,项目目录如下：</p><p><img src="/images/hexo/image1.png"></p><p><front color="red">_config.yml</front>存放的是博客的配置信息，<front color="red">source&#x2F;_post</front>是存放文章的。</p><p>修改<front color="red">_config.yml</front>相关配置</p><p><img src="/images/hexo/image2.png"></p><h5 id="2-2预览"><a href="#2-2预览" class="headerlink" title="2.2预览"></a>2.2预览</h5><p>打开终端，在根目录下执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean#清楚缓存文件，建议写完文章后执行一次</span><br><span class="line">hexo g#生成public文件夹，写完文章后执行</span><br><span class="line">hexo s#启动hexo服务</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:4000/%E7%9C%8B%E6%98%AF%E5%90%A6%E6%98%BE%E7%A4%BA%E6%88%90%E5%8A%9F">http://localhost:4000/看是否显示成功</a></p><h4 id="3-更换主题"><a href="#3-更换主题" class="headerlink" title="3.更换主题"></a>3.更换主题</h4><p>去主题官网更换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 通过 git clone 命令将主题下载到 theme 目录</span><br><span class="line">git clone https://github.com/miiiku/hexo-theme-flexblock.git ./themes/flexblock</span><br></pre></td></tr></table></figure><p>修改根目录<front color="red">_config.yml</front>中的theme</p><h4 id="4-部署到Github-Pages"><a href="#4-部署到Github-Pages" class="headerlink" title="4.部署到Github Pages"></a>4.部署到Github Pages</h4><p>登录 GitHub，新建一个 Repository，<code>Repository name</code>一定要是<code>你的用户名</code>.github.io</p><p><img src="/images/hexo/image3.png"></p><p>来到仓库主页，复制如下链接</p><p><img src="/images/hexo/image4.png"></p><p>打开博客目录下的<code>_config.yml</code>，拉到最后，填写<code>deploy</code>模块：<code>repository</code> 填写刚才复制的链接</p><p><img src="/images/hexo/image5.png"></p><hr><p><strong>一定要安装git插件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>将博客部署上去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d#执行部署</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/07/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/07/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2024/07/15/%E7%AE%97%E6%B3%95/"/>
      <url>/2024/07/15/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
